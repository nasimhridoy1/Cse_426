
#ifdef __APPLE__
#include <GLUT/glut.h>
#else
#include <GL/glut.h>
#endif

#include <iostream>
#include <cmath>
using namespace std;

// -------- Window Configuration --------
constexpr int WINDOW_WIDTH = 640;
constexpr int WINDOW_HEIGHT = 480;

// -------- Circle Parameters --------
int centerX = WINDOW_WIDTH / 2;
int centerY = WINDOW_HEIGHT / 2;

int totalRings = 10;
int baseRadius = 20;
int radiusIncrement = 15;
int baseThickness = 2;
int thicknessIncrement = 1;

// -------- Color Gradient --------
float colorStartR = 1.0f, colorStartG = 0.0f, colorStartB = 0.0f; // Red
float colorEndR   = 0.0f, colorEndG   = 0.0f, colorEndB   = 1.0f; // Blue

// Plot a single pixel
void plotPixel(int x, int y) {
    glVertex2i(x, y);
}

// Plot 8-way symmetry for circle
void plotSymmetricPoints(int cx, int cy, int x, int y) {
    plotPixel(cx + x, cy + y);
    plotPixel(cx - x, cy + y);
    plotPixel(cx + x, cy - y);
    plotPixel(cx - x, cy - y);
    plotPixel(cx + y, cy + x);
    plotPixel(cx - y, cy + x);
    plotPixel(cx + y, cy - x);
    plotPixel(cx - y, cy - x);
}

// Draw a circle with thickness
void drawRing(int cx, int cy, int radius, int thickness) {
    for (int layer = 0; layer < thickness; ++layer) {
        int r = radius + layer;
        int x = 0, y = r;
        int decision = 1 - r;

        glBegin(GL_POINTS);
        while (y >= x) {
            plotSymmetricPoints(cx, cy, x, y);
            if (decision < 0) {
                decision += 2 * x + 3;
            } else {
                decision += 2 * (x - y) + 5;
                y--;
            }
            x++;
        }
        glEnd();
    }
}

// Linear interpolation
float interpolate(float a, float b, float t) {
    return a + t * (b - a);
}

// Draw all concentric rings with gradient
void renderGradientRings() {
    for (int i = 0; i < totalRings; ++i) {
        int radius = baseRadius + i * radiusIncrement;
        int thickness = baseThickness + i * thicknessIncrement;
        float t = (totalRings > 1) ? static_cast<float>(i) / (totalRings - 1) : 0.0f;

        float r = interpolate(colorStartR, colorEndR, t);
        float g = interpolate(colorStartG, colorEndG, t);
        float b = interpolate(colorStartB, colorEndB, t);

        glColor3f(r, g, b);
        drawRing(centerX, centerY, radius, thickness);
    }
}

// Display callback
void display() {
    glClear(GL_COLOR_BUFFER_BIT);
    renderGradientRings();
    glFlush();
}

// OpenGL initialization
void setupOpenGL() {
    glClearColor(1.0, 1.0, 1.0, 0.0); // White background
    glPointSize(2.0);                // Pixel size
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(0, WINDOW_WIDTH, 0, WINDOW_HEIGHT);
}

// Main function
int main(int argc, char** argv) {
    cout << "ðŸŽ¯ Ring Painter Configuration\n";
    cout << "Enter center coordinates (e.g. 320 240): ";
    cin >> centerX >> centerY;

    cout << "Enter number of rings: ";
    cin >> totalRings;

    cout << "Enter base radius and increment: ";
    cin >> baseRadius >> radiusIncrement;

    cout << "Enter base thickness and increment: ";
    cin >> baseThickness >> thicknessIncrement;

    cout << "Enter inner RGB (0â€“1): ";
    cin >> colorStartR >> colorStartG >> colorStartB;

    cout << "Enter outer RGB (0â€“1): ";
    cin >> colorEndR >> colorEndG >> colorEndB;

    cout << "\nðŸ–Œï¸ Drawing " << totalRings << " rings from radius " << baseRadius
         << " with gradient from (" << colorStartR << ", " << colorStartG << ", " << colorStartB
         << ") to (" << colorEndR << ", " << colorEndG << ", " << colorEndB << ")\n";

    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("Gradient Ring Painter");

    setupOpenGL();
    glutDisplayFunc(display);
    glutMainLoop();

    return 0;
}
